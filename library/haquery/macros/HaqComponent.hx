package haquery.macros;

#if macro
import haxe.macro.Context;
import sys.FileSystem;
import sys.io.File;
#end

import haxe.macro.Expr;
import haxe.macro.Type;

using tink.macro.tools.MacroTools;

class HaqComponent
{
	@:macro public function template(ethis:Expr)
	{
		var pos = Context.currentPos();
		
		switch (Context.typeof(ethis))
		{
			case Type.TInst(t, params):
				var clas = t.get();
				if (clas.pack.length > 0 && (clas.pack[0] == "components" || clas.pack[0] == "pages") && (clas.name == "Server" || clas.name == "Client"))
				{
					var typePath = { sub:null, params:[], pack:clas.pack, name:"Template" + clas.name };
					return { expr:ExprDef.ENew(typePath, [ ethis ]), pos:pos };
				}
			default:
		}
		
		return Context.makeExpr(null, pos);
	}
	
	@:macro public static function build() : Array<Field>
	{
		var componentClass = Context.getLocalClass().get();
        var pos = Context.currentPos();
		
		if (componentClass.name == "Server" || componentClass.name == "Client")
		{
			var fields = Context.getBuildFields();
			setComponentClassEventHandlersArgTypes(componentClass, fields);
			return fields;
		}
		else
		{
			//log("SKIPPED: " + componentClass.pack.join(".") + "." + componentClass.name);
		}
		
		return null;
	}
	
	@:macro public function shared(ethis:Expr)
	{
		var pos = Context.currentPos();
		
		switch (Context.typeof(ethis))
		{
			case Type.TInst(t, params):
				var clas = t.get();
				if (clas.pack.length > 0 && (clas.pack[0] == "components" || clas.pack[0] == "pages") && (clas.name == "Server" || clas.name == "Client"))
				{
					var componentClassName = clas.name == "Server" ? "Client" : "Server";
					var componentClassFile = Context.resolvePath(clas.pack.join("/") + "/" + componentClassName + ".hx");
					//log("componentClassFile = " + componentClassFile);
					var sharedClassName = "Shared" + clas.name;
					var sharedClassFile = "trm/" + clas.pack.join("/") + "/" + sharedClassName + ".hx";
					//log("sharedClassFile = " + sharedClassFile);
					if (!FileSystem.exists(sharedClassFile) || FileSystem.stat(componentClassFile).mtime.getTime() > FileSystem.stat(sharedClassFile).mtime.getTime())
					{
						var componentClass = getClassType(clas.pack.join(".") + "." + componentClassName);
						var componentClassFields = [ makeSharedClassConstructor(clas.pos) ].concat(getSharedMethods(componentClass));
						
						//log("componentClassFields = " + componentClassFields.length);
						
						Context.defineType({
							  pack : clas.pack
							, name : sharedClassName
							, pos : pos
							, meta : []
							, params : []
							, isExtern : false
							, kind : TypeDefKind.TDClass(null, [], false)
							, fields : componentClassFields
						});
						
						//log("type defined");
						
						var s = "// This is autogenerated file. Do not edit!\n"
							  + "\n"
							  + "package " + clas.pack.join(".") + ";\n"
							  + "\n"
							  + "import haquery.base.HaqComponent;\n"
							  + "\n"
							  + "class " + sharedClassName + "\n"
							  + tink.macro.tools.Printer.printFields("", componentClassFields);
						
						File.saveContent(sharedClassFile, s);
					}
					
					return { expr:ExprDef.ENew(makeTypePath(clas.pack, sharedClassName, []), [ ethis ]), pos:pos };
					
				}
			default:
		}
		
		return Context.makeExpr(null, pos);
	}
	
	#if macro
	
	static function log(s:String) : Void
	{
		if (sys.FileSystem.exists("build.log"))
		{
			var log = sys.io.File.append("build.log", false);
			log.writeString(s + "\n");
			log.close();
		}
		else
		{
			sys.io.File.saveContent("build.log", s + "\n");
		}
	}
	
	static function setComponentClassEventHandlersArgTypes(componentClass:ClassType, fields:Array<Field>)
	{
		//log("setComponentClassEventHandlersArgTypes for class " + componentClass.pack.join(".") + "." + componentClass.name);
		//Context.warning("setComponentClassEventHandlersArgTypes for class " + componentClass.pack.join(".") + componentClass.name, componentClass.po);
		
		var handlers = getComponentClassHandlers(fields);
		if (handlers != null && handlers.length > 0)
		{
			var templateClass = getTemplateClass(componentClass);
			if (templateClass != null)
			{
				for (handler in handlers)
				{
					handler.args[0].type = ComplexType.TPath( { sub:null, params:[], pack:[ "haquery", (componentClass.name == "Server" ? "server" : "client") ], name:"HaqComponent" } );
						
					var splittedHandlerName = handler.name.split("_");
					var templateFieldName = splittedHandlerName.slice(0, splittedHandlerName.length - 1).join("_");
					var eventName = splittedHandlerName[splittedHandlerName.length - 1];
					
					var templateClassFieldClass = getTemplateClassFieldClass(templateClass, templateFieldName);
					if (templateClassFieldClass != null)
					{
						var eventParamType = null;
						var typePath = templateClassFieldClass.pack.join(".") + "." + templateClassFieldClass.name;
						if (typePath == "haquery.client.HaqQuery" || typePath == "js.JQuery")
						{
							eventParamType = getModuleType("js.JQuery", "JqEvent");
						}
						else
						if (typePath == "haquery.server.HaqQuery")
						{
							eventParamType = Context.getType("Dynamic");
						}
						else
						{
							eventParamType = getComponentClassEventClassParamType(templateClassFieldClass, eventName);
						}
						
						if (eventParamType != null)
						{
							handler.args[1].type = eventParamType.toComplex();
						}
					}
					else
					{
						Context.error("Field '" + templateFieldName + "' is not found in template.", handler.pos);
					}
				}
			}
			else
			{
				Context.error("To use handlers you need to have Template" + componentClass.name + " class. Check file 'template.html' existance.", componentClass.pos);
			}
		}
	}
	
	static function getComponentClassHandlers(fields:Array<Field>) : Array<{ name:String, pos:Position, args:Array<FunctionArg> }>
	{
		var handlers : Array<{ name:String, pos:Position, args:Array<FunctionArg> }> = [];
		
		for (field in fields)
		{
			switch (field.kind)
			{
				case FieldType.FFun(f):
					if (field.name.indexOf("_") > 0)
					{
						//Context.warning("Handler found: " + field.name, field.pos);
						if (f.args.length == 2)
						{
							if (f.args[0].type == null && f.args[1].type == null)
							{
								handlers.push({ name:field.name, pos:field.pos, args:f.args });
							}
							else
							{
								Context.error("Event handler's arguments types must not be specified.", field.pos);
								return null;
							}
						}
						else
						{
							Context.error("Event handler must be defined with exactly two arguments.", field.pos);
							return null;
						}
					}
				
				default:
			}
		}
		
		return handlers;
	}
	
	static function getComponentClassEventClassParamType(componentClass:ClassType, eventName:String) : Type
	{
		for (field in componentClass.fields.get())
		{
			if (field.name == "event_" + eventName)
			{
				switch (field.type)
				{
					case Type.TInst(t, params):
						if (t.get().pack.join(".") + "." + t.get().name == "haquery.common.HaqEvent")
						{
							if (params != null && params.length == 1)
							{
								//Context.getModule(t.get().module);
								//Context.warning("Event's param is " + params[0] + ".", field.pos);
								return params[0];
							}
							else
							{
								Context.error("Event's class must have param.", field.pos);
								return null;
							}
						}
						else
						{
							Context.error("Event field type must be 'haquery.common.HaqEvent<param>'.", field.pos);
							return null;
						}
					
					default:
						Context.error("Unexpected event field '" + componentClass.pack.join(".") + "." + componentClass.name + "." + field.name + "' type ('" + Std.string(field.type) + "').", field.pos);
						return null;
				}
			}
		}
		
		if (componentClass.superClass != null)
		{
			return getComponentClassEventClassParamType(componentClass.superClass.t.get(), eventName);
		}
		
		return null;
	}
	
	static function getTemplateClass(componentClass:ClassType) : ClassType
	{
		var templateClassTypes = Context.getModule(componentClass.pack.join(".") + ".Template" + componentClass.name);
		for (templateClassType in templateClassTypes)
		{
			switch (templateClassType)
			{
				case Type.TInst(templateClassRef, params):
					var templateClass = templateClassRef.get();
					if (templateClass.name == "Template" + componentClass.name)
					{
						return templateClass;
					}
				
				default:
			}
		}
		
		return null;
	}
	
	static function getTemplateClassFieldClass(templateClass:ClassType, fieldName:String) : ClassType
	{
		for (field in templateClass.fields.get())
		{
			if (field.name == fieldName)
			{
				switch (field.type)
				{
					case Type.TType(defTypeRef, _):
						switch (defTypeRef.get().type)
						{
							case Type.TInst(t, _):
								return t.get();
							
							default:
								Context.error("Field(2) '" + field.name + "' of '" + templateClass.pack.join(".") + "." + templateClass.name + "' must have a class type ('" + Std.string(defTypeRef.get().type) + "').", field.pos);
								return null;
						}
					
					case Type.TInst(t, _):
						return t.get();
						
					default:
						Context.error("Field(1) '" + field.name + "' of '" + templateClass.pack.join(".") + "." + templateClass.name + "' must have a class type ('" + Std.string(field.type) + "').", field.pos);
						return null;
				}
			}
		}
		return null;
	}
	
	static function getModuleType(module:String, typeName:String) : Type
	{
		for (type in Context.getModule(module))
		{
			switch(type)
			{
				case Type.TType(t, _):
					if (t.get().name == typeName) return t.get().type;
				
				default:
					return null;
			}
		}
		return null;
	}
	
	static function getClassType(fullName:String) : ClassType
	{
		var type = Context.getType(fullName);
		switch (type)
		{
			case Type.TInst(t, _):
				return t.get();
			default:
				return null;
		}
	}
	
	static function getSharedMethods(componentClass:ClassType) : Array<Field>
	{
		var r = new Array<Field>();
		
		for (field in componentClass.fields.get())
		{
			if (field.meta.has("shared"))
			{
				var typedFieldExpr = field.expr();
				if (typedFieldExpr != null)
				{
					//log("field typed OK: " + field.name);
					var fieldExpr = Context.getTypedExpr(field.expr());
					if (fieldExpr != null)
					{
						if (fieldExpr.expr != null)
						{
							switch (fieldExpr.expr)
							{
								case ExprDef.EFunction(name, f):
									//log("function " + field.name);
									if (componentClass.name == "Server")
									{
										r.push(makeSharedClientClassMethod(field.name, f.args, f.ret, componentClass.pos));
									}
									else
									{
										r.push(makeSharedServerClassMethod(field.name, f.args, f.ret, componentClass.pos));
									}
								
								default:
									Context.error("Use @shared for methods only.", field.pos);
							}
						}
						else
						{
							//log("fieldExpr.expr = null");
						}
					}
					else
					{
						//log("fieldExpr = null");
					}
				}
				else
				{
					//log("field typed BAD: " + field.name);
					switch (field.type)
					{
						case Type.TFun(args, ret):
							if (componentClass.name == "Server")
							{
								r.push(makeSharedClientClassMethod(field.name, funArgsToFunctionArgs(args), safeToComplex(ret), componentClass.pos));
							}
							else
							{
								r.push(makeSharedServerClassMethod(field.name, funArgsToFunctionArgs(args), safeToComplex(ret), componentClass.pos));
							}
						
						default:
							Context.error("Use @shared for methods only.", field.pos);
					}
				}
			}
		}
		
		if (componentClass.superClass != null)
		{
			r = r.concat(getSharedMethods(componentClass.superClass.t.get()));
		}
		
		return r;	
	}
	
	static function funArgsToFunctionArgs(params:Array<{ t:Type, opt:Bool, name:String }>) : Array<FunctionArg>
	{
		var r = new Array<FunctionArg>();
		for (param in params)
		{
			//var type = param.t.toComplex();
			var type = safeToComplex(param.t);
			r.push(param.name.toArg(type, param.opt));
		}
		return r;
	}
	
	static function makeTypePath(pack:Array<String>, name:String, params:Array<TypeParam>) : TypePath
	{
		return {
			  pack : pack
			, name : name
			, params : params
			, sub : null
		};
	}
	
	static function makeMethod(name:String, args:Array<FunctionArg>, ret:Null<ComplexType>, expr:Expr) : Field
	{
		return {
			  name : name
			, access : [ Access.APublic ]
			, kind : FieldType.FFun({
						  args : args
						, ret : ret
						, expr : expr
						, params : []
					  })
			, pos : expr.pos
		};
	}
	
	static function makeSharedClassConstructor(pos:Position) : Field
	{
		var assignExpr = macro this.component = component;
		return makeMethod("new", [ "component".toArg("haquery.base.HaqComponent".asComplexType()) ], ComplexType.TPath("Void".asTypePath()), assignExpr);
	}
	
	static function makeSharedClientClassMethod(name:String, args:Array<FunctionArg>, ret:Null<ComplexType>, pos:Position) : Field
	{
		var args2 : Array<FunctionArg> = Reflect.copy(args);
		args2.push("callb".toArg(macro : $ret->Void, true));
		
		var callParams = [ 
			  name.toExpr()
			, Lambda.map(args, function(a) return Context.parse(a.name, pos)).toArray()
			, macro callb
		];
		var callExpr = ExprDef.ECall(macro component.callSharedMethod, callParams).at(pos);
		return makeMethod(name, args2, macro : Void, callExpr);
	}
	
	static function makeSharedServerClassMethod(name:String, args:Array<FunctionArg>, ret:Null<ComplexType>, pos:Position) : Field
	{
		var callParams = [ 
			  name.toExpr()
			, Lambda.map(args, function(a) return Context.parse(a.name, pos)).toArray()
		];
		var callExpr = ExprDef.ECall(macro component.callSharedMethod, callParams).at(pos);
		return makeMethod(name, args, macro : Void, callExpr);
	}
	
	static function safeToComplex(type:Type) : ComplexType
	{
		switch (type)
		{
			case Type.TMono(t):
				return safeToComplex(t.get());
			
			case Type.TInst(t, params):
				var tt = t.get();
				return ComplexType.TPath(makeTypePath(tt.pack, tt.name, typesToTypeParams(params)));
			
			case Type.TEnum(t, params):
				var tt = t.get();
				return ComplexType.TPath(makeTypePath(tt.pack, tt.name, typesToTypeParams(params)));
			
			case Type.TAnonymous(a):
				var aa = a.get();
				return ComplexType.TAnonymous(Lambda.array(Lambda.map(aa.fields, classFieldToField)));
			
			default:
				return ComplexType.TPath("Dynamic".asTypePath());
		}
	}
	
	static function typesToTypeParams(types:Array<Type>) : Array<TypeParam>
	{
		return Lambda.array(Lambda.map(types, function (t) return TypeParam.TPType(safeToComplex(t))));
	}
	
	static function classFieldToField(field:ClassField) : Field
	{
		return {
			  name : field.name
			, doc : field.doc
			, access : []
			, kind : FieldType.FVar(safeToComplex(field.type))
			, pos : field.pos
			, meta : field.meta.get()
		};
	}
	
	#end
}