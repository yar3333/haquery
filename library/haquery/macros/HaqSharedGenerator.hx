package haquery.macros;

#if macro
import haxe.macro.Context;
import sys.FileSystem;
import sys.io.File;
import haxe.io.Path;
#end

import haxe.macro.Expr;
import haxe.macro.Type;

using tink.macro.tools.MacroTools;

class HaqSharedGenerator
{
	#if macro
	
	public static function generate(clas:ClassType)
	{
		if (clas.pack.length > 0 && (clas.pack[0] == "components" || clas.pack[0] == "pages") && (clas.name == "Server" || clas.name == "Client"))
		{
			var componentClassFile = Context.resolvePath(StringTools.replace(clas.module, ".", "/") + ".hx");
			var sharedClassName = "Shared" + (clas.name == "Server" ? "Client" : "Server");
			var sharedClassFile = "trm/" + clas.pack.join("/") + "/" + sharedClassName + ".hx";
			if (!FileSystem.exists(sharedClassFile) || FileSystem.stat(componentClassFile).mtime.getTime() > FileSystem.stat(sharedClassFile).mtime.getTime())
			{
				var componentField = macro var component:HaqComponent;
				var componentClassFields = [ 
					  HaqTools.makeVar("component", ComplexType.TPath(HaqTools.makeTypePath([ "haquery", clas.name == "Server" ? "client" : "server" ], "HaqComponent", [])), null)
					, makeSharedClassConstructor(clas) 
				].concat(getSharedMethods(clas));
				
				var renderedClassFields = tink.macro.tools.Printer.printFields("", componentClassFields);
				renderedClassFields = StringTools.replace(renderedClassFields, "};", "}");
				
				var s = "// This is autogenerated file. Do not edit!\n"
					  + "\n"
					  + "package " + clas.pack.join(".") + ";\n"
					  + "\n"
					  + "class " + sharedClassName + "\n"
					  + renderedClassFields;
				
				HaqTools.createDirectory(Path.directory(sharedClassFile));
				File.saveContent(sharedClassFile, s);
			}
		}
	}
	
	static function getSharedMethods(componentClass:ClassType) : Array<Field>
	{
		var r = new Array<Field>();
		
		for (field in componentClass.fields.get())
		{
			if (field.meta.has("shared"))
			{
				var shared = Lambda.filter(field.meta.get(), function(m) return m.name == "shared").first();
				var IsWebsocketSupported = shared.params.length > 0 && HaqTools.stringConstExpr2string(shared.params[0]) == "websocket";
				
				var typedFieldExpr = field.expr();
				if (typedFieldExpr != null)
				{
					var fieldExpr = Context.getTypedExpr(field.expr());
					if (fieldExpr != null)
					{
						if (fieldExpr.expr != null)
						{
							switch (fieldExpr.expr)
							{
								case ExprDef.EFunction(name, f):
									if (componentClass.name == "Server")
									{
										r.push(makeSharedClientClassMethod(IsWebsocketSupported, field.name, f.args, f.ret, componentClass.pos));
									}
									else
									{
										r.push(makeSharedServerClassMethod(field.name, f.args, f.ret, componentClass.pos));
									}
								
								default:
									Context.error("Use @shared for methods only.", field.pos);
							}
						}
						else
						{
							//log("fieldExpr.expr = null");
						}
					}
					else
					{
						//log("fieldExpr = null");
					}
				}
				else
				{
					//log("field typed BAD: " + field.name);
					switch (field.type)
					{
						case Type.TFun(args, ret):
							if (componentClass.name == "Server")
							{
								r.push(makeSharedClientClassMethod(IsWebsocketSupported, field.name, HaqTools.funArgsToFunctionArgs(args), HaqTools.safeToComplex(ret), componentClass.pos));
							}
							else
							{
								r.push(makeSharedServerClassMethod(field.name, HaqTools.funArgsToFunctionArgs(args), HaqTools.safeToComplex(ret), componentClass.pos));
							}
						
						default:
							Context.error("Use @shared for methods only.", field.pos);
					}
				}
			}
		}
		
		if (componentClass.superClass != null)
		{
			r = r.concat(getSharedMethods(componentClass.superClass.t.get()));
		}
		
		return r;	
	}
	
	static function makeSharedClassConstructor(clas:ClassType) : Field
	{
		var assignExpr = macro { this.component = component; };
		return HaqTools.makeMethod("new", [ "component".toArg(("haquery." + (clas.name == "Server" ? "client" : "server") + ".HaqComponent").asComplexType()) ], ComplexType.TPath("Void".asTypePath()), assignExpr);
	}
	
	static function makeSharedClientClassMethod(IsWebsocketSupported:Bool, name:String, args:Array<FunctionArg>, ret:Null<ComplexType>, pos:Position) : Field
	{
		var args2 : Array<FunctionArg> = Reflect.copy(args);
		args2.push("callb".toArg(macro : $ret->Void, true));
		
		var callParams = [ 
			  name.toExpr()
			, Lambda.map(args, function(a) return Context.parse(a.name, pos)).toArray()
			, !HaqTools.isVoid(ret) ? macro callb : macro function(_) callb()
		];
		var callExpr = IsWebsocketSupported
			? ExprDef.EBlock( [ ExprDef.ECall(macro component.callSharedMethodWebsocket, callParams).at(pos) ] ).at(pos)
			: ExprDef.EBlock( [ ExprDef.ECall(macro component.callSharedMethodAjax,      callParams).at(pos) ] ).at(pos);
		return HaqTools.makeMethod(name, args2, macro : Void, callExpr);
	}
	
	static function makeSharedServerClassMethod(name:String, args:Array<FunctionArg>, ret:Null<ComplexType>, pos:Position) : Field
	{
		var callParams = [ 
			  name.toExpr()
			, Lambda.map(args, function(a) return Context.parse(a.name, pos)).toArray()
		];
		var callExpr = ExprDef.EBlock([ ExprDef.ECall(macro component.callSharedMethod, callParams).at(pos) ]).at(pos);
		return HaqTools.makeMethod(name, args, macro : Void, callExpr);
	}
	
	#end
}