package haquery.tools.trm;

import haquery.tools.Hant;
import haquery.tools.HaqTemplateManager;
import haquery.tools.HaxeClass;
import haxe.io.Path;
import haxe.htmlparser.HtmlNodeElement;
import sys.io.File;

using haquery.StringTools;

class TrmGenerator
{
	var manager : HaqTemplateManager;
	var hant : Hant;
	
	public static function run(manager:HaqTemplateManager, hant:Hant)
	{
		new TrmGenerator(manager, hant);
	}
	
	function new(manager:HaqTemplateManager, hant:Hant)
    {
		this.manager = manager;
		this.hant = hant;
		
		for (fullTag in manager.getLastMods().keys())
		{
			generate(fullTag);
		}
    }
	
	function generate(fullTag:String)
	{
		var template = manager.get(fullTag);
		
		if (template.hasLocalServerClass || template.hasLocalClientClass)
		{
			var serverVars = getTemplateVars(fullTag, template.doc, "haquery.server.HaqQuery", true);
			if (serverVars.length > 0 && template.hasLocalServerClass)
			{
				generateTrmClass(serverVars, fullTag + ".TemplateServer", template.trmServerFilePath, "haquery.server.HaqComponent");
			}
			else
			{
				hant.deleteFile(template.trmServerFilePath);
			}
				
			var clientVars = getTemplateVars(fullTag, template.doc, "haquery.client.HaqQuery", false);
			if (clientVars.length > 0 && template.hasLocalClientClass)
			{
				generateTrmClass(clientVars, fullTag + ".TemplateClient", template.trmClientFilePath, "haquery.client.HaqComponent");
			}
			else
			{
				hant.deleteFile(template.trmClientFilePath);
			}
		}
	}
	
	function generateTrmClass(vars:Array<HaxeVarGetter>, className:String, classFilePath:String, stdComponentClassName:String)
	{
		var haxeClass = new HaxeClass(className);
		haxeClass.addVar(createVar("component", stdComponentClassName), true);
		
		for (v in vars)
		{
			haxeClass.addVarGetter(v, false, false, true);
		}
		
		haxeClass.addMethod(
			 "new"
			,[ createVar("component", stdComponentClassName) ]
			,"Void"
			,"this.component = component;"
		);
		
		hant.createDirectory(Path.directory(classFilePath));
		
		File.saveContent(
			 classFilePath
			,"// This is autogenerated file. Do not edit!\n\n" + haxeClass.toString() + "\n"
		);
	}
	
	function getTemplateVars(fullTag:String, node:HtmlNodeElement, queryClassName:String, isServer:Bool) : Array<HaxeVarGetter>
	{
		var r : Array<HaxeVarGetter> = [];
		var children = node.children;
		for (child in children)
		{
			if (child.hasAttribute("id") && child.getAttribute("id").trim() != "")
			{
				var componentID = child.getAttribute("id").trim();
				
				var type = queryClassName;
				var body = "return component.q('#" + componentID + "');";
				if (child.name.startsWith("haq:"))
				{
					var tag = child.name.substr("haq:".length).replace("-", ".");
					var template = manager.findTemplate(fullTag, tag);
					if (template == null)
					{
						throw "Template not found: '" + tag + "' from '" + fullTag + "'.";
					}
					type = isServer ? template.serverClassName : template.clientClassName;
					body = "return cast component.components.get('" + componentID + "');";
				}
				
				r.push({ haxeName:componentID, haxeType:type, haxeBody:body });
			}
			
			if (isProcessNodeInner(fullTag, child.name))
			{
				r = r.concat(getTemplateVars(fullTag, child, queryClassName, isServer));
			}
		}
		return r;
	}
	
	function createVar(name:String, type:String, defVal:String = null) : HaxeVar
	{
		return {
			 haxeName : name
			,haxeType : type
			,haxeDefVal : defVal
		};
	}
	
	function isProcessNodeInner(fullTag:String, nodeName:String)
	{
		if (nodeName.startsWith("haq:"))
		{
			var tag = nodeName.substr("haq:".length).replace("-", ".");
			var template = manager.findTemplate(fullTag, tag);
			
			while (template != null)
			{
				if (template.fullTag == "components.haquery.factory")
				{
					return false;
				}
				template = template.extend != null && template.extend != "" ? manager.get(template.extend) : null;
			}
		}
		return true;
	}
}
